using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;

public class 副本_房间_地图管理
{
    public int 中心行;
    public int 中心列;
    public int 行数;
    public int 列数;
    public 副本_房间_地图_格子[,] 格子数组;
    // 把地图 上下左右 中心的五个点位单独写出来 由于游戏里 每个单位占用的格子是3*3的 正数或者倒数第二行或者列 才开始计算点位
    public 副本_房间_地图_格子 中心格子 => 格子数组[中心行, 中心列];
    public 副本_房间_地图_格子 上边中心 => 格子数组[行数 - 2, 中心列];
    public 副本_房间_地图_格子 下边中心 => 格子数组[1, 中心列];
    public 副本_房间_地图_格子 左边中心 => 格子数组[中心行, 1];
    public 副本_房间_地图_格子 右边中心 => 格子数组[中心行, 列数 - 2];
    public List<副本_房间_地图_格子> 初始状态格子列表;
    private bool 在范围内(int 行, int 列)
    {
        return 行 >= 0 && 行 < 行数 && 列 >= 0 && 列 < 列数;
    }
    public 副本_房间_地图_格子 取格子或空(int 行, int 列)
    {
        return 在范围内(行, 列) ? 格子数组[行, 列] : null;
    }
    public 副本_房间_地图_格子 目标格子上(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行 + 1, 检查格子.列);
    public 副本_房间_地图_格子 目标格子下(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行 - 1, 检查格子.列);
    public 副本_房间_地图_格子 目标格子左(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行, 检查格子.列 - 1);
    public 副本_房间_地图_格子 目标格子右(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行, 检查格子.列 + 1);
    public 副本_房间_地图_格子 目标格子左上(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行 + 1, 检查格子.列 - 1);
    public 副本_房间_地图_格子 目标格子右上(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行 + 1, 检查格子.列 + 1);
    public 副本_房间_地图_格子 目标格子左下(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行 - 1, 检查格子.列 - 1);
    public 副本_房间_地图_格子 目标格子右下(副本_房间_地图_格子 检查格子) => 取格子或空(检查格子.行 - 1, 检查格子.列 + 1);
    public 副本_房间_地图管理(int 行数 = 30, int 列数 = 30)
    {
        this.行数 = 行数;
        this.列数 = 列数;
        this.中心行 = 行数 / 2;
        this.中心列 = 列数 / 2;
        this.格子数组 = new 副本_房间_地图_格子[行数, 列数];
        for (int 行 = 0; 行 < 行数; 行++)
        {
            for (int 列 = 0; 列 < 列数; 列++)
            {
                this.格子数组[行, 列] = new 副本_房间_地图_格子(行, 列);
            }
        }
    }
    public void 初始化地图格子()
    {
        初始状态格子列表 = new List<副本_房间_地图_格子>();
        for (int 行 = 0; 行 < 行数; 行++)
        {
            for (int 列 = 0; 列 < 列数; 列++)
            {
                this.格子数组[行, 列].存在单位 = false;
                this.格子数组[行, 列].单位 = null;
            }
        }
    }
    public void 分配玩家单位坐标(副本单位[] 副本上阵单位数组, 副本_房间 当前房间, 副本_房间 上一个房间)
    {
        // 根据上一个房间位置确定起点：入口房间用中心，其他房间根据进入方向选择边缘中心
        // var 当前格子 = 上一个房间 == null ? 中心格子 :
        //           当前房间.行 == 上一个房间.行 ? (当前房间.列 < 上一个房间.列 ? 左边中心 : 右边中心) :
        //           当前房间.列 == 上一个房间.列 ? (当前房间.行 < 上一个房间.行 ? 上边中心 : 下边中心) : null;

        int 起点行 = 1;
        int 起点列 = 1;
        foreach(var r in 副本上阵单位数组)
        {
            // if(!检查点位能否放置单位(当前格子))
            // {
            //     当前格子 = 选择新格子(当前格子);
            // }
            if(!r.存在单位)continue;
            分配格子单位(r, 格子数组[起点行, 起点列]);
            起点列 += 3;
            if(起点列 > 列数-1)
            {
                起点行 += 3;
                起点列 = 1;
            }
        }
    }
    public void 分配房间单位坐标(副本_房间 当前房间, 副本_房间 上一个房间)
    {
        int 起点行 = 行数 - 2;
        int 起点列 = 列数 - 2;
        switch(当前房间.房间类型)
        {
            case 副本房间类型.战斗:
                foreach(var r in 当前房间.首领列表)
                {
                    确定单位坐标(r, 格子数组[起点行, 起点列]);
                    起点列 -= 3;
                    if(起点列 < 1)
                    {
                        起点行 -= 3;
                        起点列 = 列数 - 2;
                    }
                }
                foreach(var r in 当前房间.精英列表)
                {
                    确定单位坐标(r, 格子数组[起点行, 起点列]);
                    起点列 -= 3;
                    if(起点列 < 1)
                    {
                        起点行 -= 3;
                        起点列 = 列数 - 2;
                    }
                }
                foreach(var r in 当前房间.小怪列表)
                {
                    确定单位坐标(r, 格子数组[起点行, 起点列]);
                    起点列 -= 3;
                    if(起点列 < 1)
                    {
                        起点行 -= 3;
                        起点列 = 列数 - 2;
                    }
                }
                break;
        }
    }
    private bool 检查点位能否放置单位(副本_房间_地图_格子 当前点位)
    {
        return !当前点位.存在单位 &&
               !目标格子上(当前点位).存在单位 &&
               !目标格子下(当前点位).存在单位 &&
               !目标格子左(当前点位).存在单位 &&
               !目标格子右(当前点位).存在单位 &&
               !目标格子左上(当前点位).存在单位 &&
               !目标格子右上(当前点位).存在单位 &&
               !目标格子左下(当前点位).存在单位 &&
               !目标格子右下(当前点位).存在单位;
    }
    // private 副本_房间_地图_格子 选择新格子(副本_房间_地图_格子 当前格子)
    // {
    //     return null; // 简单实现：返回null表示无法选择新格子
    // }
    private void 确定单位坐标(副本单位 副本单位, 副本_房间_地图_格子 当前格子)
    {
        分配格子单位(副本单位, 当前格子);
        
    }

    public void 分配格子单位(副本单位 副本单位, 副本_房间_地图_格子 当前格子)
    {
        // string str = $"正在给{副本单位.所属阵营}单位分配格子:";
        副本单位.所在格子 = 当前格子;
        // str += $"当前格子:{当前格子.行},{当前格子.列}已分配当前单位";
        给格子分配单位(当前格子, true, 副本单位);
        // str += $"当前格子上:{目标格子上(当前格子).行},{目标格子上(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子上(当前格子), true, 副本单位);
        // str += $"当前格子下:{目标格子下(当前格子).行},{目标格子下(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子下(当前格子), true, 副本单位);
        // str += $"当前格子左:{目标格子左(当前格子).行},{目标格子左(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子左(当前格子), true, 副本单位);
        // str += $"当前格子右:{目标格子右(当前格子).行},{目标格子右(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子右(当前格子), true, 副本单位);
        // str += $"当前格子左上:{目标格子左上(当前格子).行},{目标格子左上(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子左上(当前格子), true, 副本单位);
        // str += $"当前格子右上:{目标格子右上(当前格子).行},{目标格子右上(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子右上(当前格子), true, 副本单位);
        // str += $"当前格子左下:{目标格子左下(当前格子).行},{目标格子左下(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子左下(当前格子), true, 副本单位);
        // str += $"当前格子右下:{目标格子右下(当前格子).行},{目标格子右下(当前格子).列}已分配当前单位";
        给格子分配单位(目标格子右下(当前格子), true, 副本单位);
        // Debug.Log(str);
    }
    public void 清理格子单位(副本_房间_地图_格子 当前格子)
    {
        给格子分配单位(当前格子, false, null);
        给格子分配单位(目标格子上(当前格子), false, null);
        给格子分配单位(目标格子下(当前格子), false, null);
        给格子分配单位(目标格子左(当前格子), false, null);
        给格子分配单位(目标格子右(当前格子), false, null);
        给格子分配单位(目标格子左上(当前格子), false, null);
        给格子分配单位(目标格子右上(当前格子), false, null);
        给格子分配单位(目标格子左下(当前格子), false, null);
        给格子分配单位(目标格子右下(当前格子), false, null);
    }
    private void 给格子分配单位(副本_房间_地图_格子 当前格子, bool 存在单位 = false, 副本单位 副本单位 = null)
    {
        当前格子.存在单位 = 存在单位;
        当前格子.单位 = 副本单位;
    }

    public void 计算格子上单位的可移动范围(副本单位脚本 副本单位)
    {
        if(副本单位.可移动范围字典 == null)
            副本单位.可移动范围字典 = new Dictionary<副本_房间_地图_格子, List<副本_房间_地图_格子>>();
        副本单位.可移动范围字典.Clear();
        副本单位.可移动范围格子哈希集.Clear();
        副本_房间_地图_格子 单位所在格子 = 副本单位.单位.所在格子;
        int 每点行动力可移动格子距离 = 副本单位.单位.角色属性.敏捷;
        float 本次移动可移动的格子距离 = 副本单位.单位.剩余行动力 * 每点行动力可移动格子距离;
        if(本次移动可移动的格子距离==0) return;

        Queue<副本_房间_地图_格子> 待处理队列 = new Queue<副本_房间_地图_格子>();
        Dictionary<副本_房间_地图_格子, float> 距离字典 = new Dictionary<副本_房间_地图_格子, float>();
        HashSet<副本_房间_地图_格子> 已访问集合 = new HashSet<副本_房间_地图_格子>();

        待处理队列.Enqueue(单位所在格子);
        距离字典[单位所在格子] = 0;
        while (待处理队列.Count > 0)
        {
            副本_房间_地图_格子 当前格子 = 待处理队列.Dequeue();
            float 当前距离 = 距离字典[当前格子];
            //Debug.Log($"当前距离={当前距离},本次移动可移动的格子距离={本次移动可移动的格子距离}");
            if (已访问集合.Contains(当前格子) || 当前距离 > 本次移动可移动的格子距离)
            {
                continue;
            }
            已访问集合.Add(当前格子);
            bool 符合移动条件 = true;
            副本_房间_地图_格子[] 范围格子数组 = {
            当前格子,
            目标格子上(当前格子),
            目标格子下(当前格子),
            目标格子左(当前格子),
            目标格子右(当前格子),
            目标格子左上(当前格子),
            目标格子右上(当前格子),
            目标格子左下(当前格子),
            目标格子右下(当前格子)
        };
            for (int i = 0; i < 9; i++)
            {
                if (范围格子数组[i] == null)
                {
                    符合移动条件 = false;
                    break;
                }
                if (范围格子数组[i].存在单位 && 范围格子数组[i].单位 != 副本单位.单位)
                {
                    符合移动条件 = false;
                    break;
                }
            }

            if (符合移动条件)
            {
                for (int i = 0; i < 9; i++)
                {
                    var r = 范围格子数组[i];
                    副本单位.可移动范围格子哈希集.Add(r);
                    if(i==0) continue;
                    if (r != null && !已访问集合.Contains(r) && !距离字典.ContainsKey(r))
                    {
                        float 移动消耗 = (i <= 4) ? 1 : 1.5f; // 1234是上下左右+1，5678是角落+2
                        float 新距离 = 当前距离 + 移动消耗;
                        待处理队列.Enqueue(r);
                        距离字典[r] = 新距离;
                    }
                }
                if (当前格子 != 单位所在格子)
                {
                    if (!副本单位.可移动范围字典.ContainsKey(当前格子))
                        副本单位.可移动范围字典[当前格子] = new List<副本_房间_地图_格子>();
                    副本单位.可移动范围字典[当前格子].AddRange(范围格子数组);
                }
            }
        }
    }
}
