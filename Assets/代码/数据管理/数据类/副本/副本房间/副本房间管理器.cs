using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class 副本房间管理器
{
    public int 副本房间行数;
    public int 副本房间列数;
    public 副本房间[,] 副本房间数组;
    public 副本房间 入口;
    public 副本房间 出口;
    public 副本房间 当前所在房间;
    public List<副本房间> 主路径房间列表;
    public List<副本房间> 可分配房间列表;

    public 副本房间管理器(int 副本大小分行 = 5, int 副本大小分列 = 5)
    {
        副本房间行数 = 副本大小分行;
        副本房间列数 = 副本大小分列;
        副本房间数组 = new 副本房间[副本大小分行, 副本大小分列];
        初始化副本房间数据();
    }

    public 副本房间 周边房间_上(副本房间 目标房间 = null) => 获取指定方向房间(目标房间, 1, 0);
    public 副本房间 周边房间_下(副本房间 目标房间 = null) => 获取指定方向房间(目标房间, -1, 0);
    public 副本房间 周边房间_左(副本房间 目标房间 = null) => 获取指定方向房间(目标房间, 0, -1);
    public 副本房间 周边房间_右(副本房间 目标房间 = null) => 获取指定方向房间(目标房间, 0, 1);

    private 副本房间 获取指定方向房间(副本房间 目标房间, int 行偏移, int 列偏移)
    {
        var 基准房间 = 目标房间 ?? 当前所在房间;
        if (基准房间 == null) return null;
        int 目标行 = 基准房间.行 + 行偏移;
        int 目标列 = 基准房间.列 + 列偏移;
        return (目标行 >= 0 && 目标行 < 副本房间行数 && 目标列 >= 0 && 目标列 < 副本房间列数) ? 副本房间数组[目标行, 目标列] : null;
    }

    private List<副本房间> 获取周边房间(副本房间 房间) => new List<副本房间> { 周边房间_上(房间), 周边房间_下(房间), 周边房间_左(房间), 周边房间_右(房间) };

    private void 初始化副本房间数据()
    {
        可分配房间列表 = new List<副本房间>();
        初始化每个房间();
        初始化入口和出口();
        初始化副本主路径();
    }

    private void 初始化每个房间()
    {
        for (int 行 = 0; 行 < 副本房间行数; 行++)
            for (int 列 = 0; 列 < 副本房间列数; 列++)
            {
                副本房间数组[行, 列] = new 副本房间(行, 列);
                可分配房间列表.Add(副本房间数组[行, 列]);
            }
    }

    private void 初始化入口和出口()
    {
        bool 选择行边 = this.随机数(0, 1) == 0;
        bool 入口在第一边 = this.随机数(0, 1) == 0;
        var (入口位置, 出口位置) = 生成相对边位置(选择行边, 入口在第一边);
        入口 = 副本房间数组[入口位置.x, 入口位置.y];
        入口.房间类型 = 副本房间类型.入口;
        入口.路径类型 = 副本房间路径类型.主路;
        出口 = 副本房间数组[出口位置.x, 出口位置.y];
        出口.房间类型 = 副本房间类型.出口;
        出口.路径类型 = 副本房间路径类型.主路;
        可分配房间列表.Remove(入口);
        可分配房间列表.Remove(出口);
    }

    private (Vector2Int 入口位置, Vector2Int 出口位置) 生成相对边位置(bool 是行边, bool 入口在第一边)
    {
        if (是行边)
        {
            int 入口列 = this.随机数(0, 副本房间列数 - 1);
            int 出口列 = this.随机数(0, 副本房间列数 - 1);
            return 入口在第一边 ? (new Vector2Int(0, 入口列), new Vector2Int(副本房间行数 - 1, 出口列)) : (new Vector2Int(副本房间行数 - 1, 入口列), new Vector2Int(0, 出口列));
        }
        else
        {
            int 入口行 = this.随机数(0, 副本房间行数 - 1);
            int 出口行 = this.随机数(0, 副本房间行数 - 1);
            return 入口在第一边 ? (new Vector2Int(入口行, 0), new Vector2Int(出口行, 副本房间列数 - 1)) : (new Vector2Int(入口行, 副本房间列数 - 1), new Vector2Int(出口行, 0));
        }
    }

    private void 初始化副本主路径(int 期望路径长度 = 15)
    {
        主路径房间列表 = new List<副本房间>();
        生成最短路径();
        生成延长路径(期望路径长度);
        设置路径房间();
        生成分支路径();
    }

    private void 生成最短路径()
    {
        int 当前行 = 入口.行, 当前列 = 入口.列, 目标行 = 出口.行, 目标列 = 出口.列;
        副本房间 当前房间 = 副本房间数组[当前行, 当前列];
        当前房间.路径类型 = 副本房间路径类型.主路;
        主路径房间列表.Add(当前房间);
        while (当前行 != 目标行 || 当前列 != 目标列)
        {
            if (当前行 != 目标行) 当前行 += 当前行 < 目标行 ? 1 : -1;
            else if (当前列 != 目标列) 当前列 += 当前列 < 目标列 ? 1 : -1;
            当前房间 = 副本房间数组[当前行, 当前列];
            当前房间.路径类型 = 副本房间路径类型.主路;
            主路径房间列表.Add(当前房间);
        }
    }

    private void 生成延长路径(int 最小路径长度)
    {
        while (主路径房间列表.Count < 最小路径长度)
        {
            if (!尝试扩展路径(4) && !尝试扩展路径(3) && !尝试扩展路径(2)) break;
        }
    }

    private struct 可扩展格子
    {
        public List<副本房间> 主路径格子;
        public List<副本房间> 扩展格子;
        public int 插入索引;
        public 可扩展格子(List<副本房间> 主路径格子, List<副本房间> 扩展格子, int 插入索引)
        {
            this.主路径格子 = 主路径格子;
            this.扩展格子 = 扩展格子;
            this.插入索引 = 插入索引;
        }
    }

    private bool 尝试扩展路径(int 连接数)
    {
        var 可扩展格子列表 = 寻找可扩展格子(连接数);
        if (可扩展格子列表.Count == 0) return false;
        应用路径扩展(可扩展格子列表.随机返回(), 连接数);
        return true;
    }

    private void 应用路径扩展(可扩展格子 格子数据, int 连接数)
    {
        foreach (var 格子 in 格子数据.扩展格子) 格子.路径类型 = 副本房间路径类型.主路;
        for (int i = 格子数据.扩展格子.Count - 1; i >= 0; i--) 主路径房间列表.Insert(格子数据.插入索引 + 1, 格子数据.扩展格子[i]);
        if (连接数 >= 3)
        {
            var 移除格子数 = 连接数 - 2;
            for (int i = 1; i <= 移除格子数; i++)
            {
                格子数据.主路径格子[i].路径类型 = 副本房间路径类型.阻挡;
                主路径房间列表.Remove(格子数据.主路径格子[i]);
            }
        }
    }

    private List<可扩展格子> 寻找可扩展格子(int 连接数)
    {
        var 可扩展格子列表 = new List<可扩展格子>();
        var 最大索引 = 主路径房间列表.Count - 连接数 + 1;
        for (int i = 0; i < 最大索引; i++)
        {
            var 主路径格子 = new List<副本房间>();
            for (int j = 0; j < 连接数; j++) 主路径格子.Add(主路径房间列表[i + j]);
            bool 同行 = 检查同行(主路径格子), 同列 = 检查同列(主路径格子);
            if (!同行 && !同列) continue;
            var 方向列表 = new System.Func<副本房间, 副本房间>[] { 周边房间_上, 周边房间_下, 周边房间_左, 周边房间_右 };
            foreach (var 方向方法 in 方向列表)
            {
                var 扩展格子 = new List<副本房间>();
                bool 可扩展 = true;
                foreach (var 格子 in 主路径格子)
                {
                    var 扩展格子单个 = 方向方法(格子);
                    if (扩展格子单个 == null || 扩展格子单个.路径类型 == 副本房间路径类型.主路) { 可扩展 = false; break; }
                    扩展格子.Add(扩展格子单个);
                }
                if (可扩展) 可扩展格子列表.Add(new 可扩展格子(主路径格子, 扩展格子, i));
            }
        }
        return 可扩展格子列表;
    }
    private bool 检查同行(List<副本房间> 格子列表) => 格子列表.Count <= 1 || 格子列表.All(格子 => 格子.行 == 格子列表[0].行);
    private bool 检查同列(List<副本房间> 格子列表) => 格子列表.Count <= 1 || 格子列表.All(格子 => 格子.列 == 格子列表[0].列);

    private void 设置路径房间()
    {
        for (int i = 0; i < 主路径房间列表.Count - 1; i++)
        {
            var r = 主路径房间列表[i];
            连接房间门(主路径房间列表[i], 主路径房间列表[i + 1]);
            可分配房间列表.Remove(主路径房间列表[i]);
        }
        可分配房间列表.Remove(主路径房间列表[主路径房间列表.Count - 1]);
    }

    private void 连接房间门(副本房间 f1, 副本房间 f2)
    {
        if (周边房间_上(f1) == f2) { f1.上 = f2.下 = true; }
        else if (周边房间_下(f1) == f2) { f1.下 = f2.上 = true; }
        else if (周边房间_左(f1) == f2) { f1.左 = f2.右 = true; }
        else if (周边房间_右(f1) == f2) { f1.右 = f2.左 = true; }
    }

    private void 生成分支路径()
    {
        while (可分配房间列表.Count > 0)
        {
            var 随机房间 = 可分配房间列表.随机返回();
            可分配房间列表.Remove(随机房间);
            生成一条支路(随机房间);
        }
    }

    private void 生成一条支路(副本房间 房间)
    {
        int 支路最大长度 = this.随机数(1, 3), 支路当前长度 = 1, 安全计数器 = 0;
        const int 最大循环次数 = 20;
        副本房间 当前房间 = 房间;
        当前房间.路径类型 = 副本房间路径类型.分支;
        bool 已连到主路 = false;
        while (true)
        {
            if (++安全计数器 > 最大循环次数) break;
            var 可扩展方向列表 = 获取可扩展方向(当前房间);
            if (可扩展方向列表.Count > 0)
            {
                var 选定方向 = 可扩展方向列表.随机返回();
                var 新房间 = 选定方向.方向方法(当前房间);
                新房间.路径类型 = 副本房间路径类型.分支;
                可分配房间列表.Remove(新房间);
                连接房间门(当前房间, 新房间);
                当前房间 = 新房间;
                支路当前长度++;
            }
            else
            {
                var 可连通房间列表 = 获取可连通房间(当前房间);
                if (可连通房间列表.Count > 0)
                {
                    连接房间门(当前房间, 可连通房间列表.随机返回());
                    已连到主路 = true;
                }
                else
                {
                    var 未连通支路列表 = 获取未连通支路房间(当前房间);
                    if (未连通支路列表.Count > 0) 连接房间门(当前房间, 未连通支路列表.随机返回());
                }
                if (!已连到主路)
                {
                    var 主路支路配对列表 = 获取全部主路支路配对();
                    if (主路支路配对列表.Count > 0)
                    {
                        var 选定配对 = 主路支路配对列表.随机返回();
                        连接房间门(选定配对.支路房间, 选定配对.主路房间);
                        已连到主路 = true;
                    }
                }
                break;
            }
        }
    }

    private struct 支路方向
    {
        public System.Func<副本房间, 副本房间> 方向方法;
        public string 方向名称;
        public 支路方向(System.Func<副本房间, 副本房间> 方法, string 名称) { 方向方法 = 方法; 方向名称 = 名称; }
    }

    private struct 主路支路配对
    {
        public 副本房间 主路房间;
        public 副本房间 支路房间;
        public 主路支路配对(副本房间 主路房间, 副本房间 支路房间)
        {
            this.主路房间 = 主路房间;
            this.支路房间 = 支路房间;
        }
    }

    private List<支路方向> 获取可扩展方向(副本房间 房间)
    {
        var 可扩展方向 = new List<支路方向>();
        var 所有方向 = new List<支路方向> { new 支路方向(周边房间_上, "上"), new 支路方向(周边房间_下, "下"), new 支路方向(周边房间_左, "左"), new 支路方向(周边房间_右, "右") };
        foreach (var 方向 in 所有方向)
        {
            var 目标房间 = 方向.方向方法(房间);
            if (目标房间 != null && 目标房间.路径类型 == 副本房间路径类型.阻挡) 可扩展方向.Add(方向);
        }
        return 可扩展方向;
    }

    private List<副本房间> 获取可连通房间(副本房间 房间)
    {
        var 可连通房间 = new List<副本房间>();
        foreach (var 周边房间 in 获取周边房间(房间))
            if (周边房间 != null && 周边房间.路径类型 == 副本房间路径类型.主路 && 周边房间 != 出口) 可连通房间.Add(周边房间);
        return 可连通房间;
    }

    private List<副本房间> 获取未连通支路房间(副本房间 房间)
    {
        var 未连通支路房间 = new List<副本房间>();
        var 周边房间列表 = 获取周边房间(房间);
        for (int i = 0; i < 周边房间列表.Count; i++)
        {
            var 周边房间 = 周边房间列表[i];
            if (周边房间?.路径类型 == 副本房间路径类型.分支)
            {
                bool 已连通 = (i == 0 && 房间.上) || (i == 1 && 房间.下) || (i == 2 && 房间.左) || (i == 3 && 房间.右);
                if (!已连通) 未连通支路房间.Add(周边房间);
            }
        }
        return 未连通支路房间;
    }

    private List<主路支路配对> 获取全部主路支路配对()
    {
        var 配对列表 = new List<主路支路配对>();
        var 全部支路房间 = 获取全部支路房间();
        foreach (var 支路房间 in 全部支路房间)
        {
            var 周边主路房间列表 = 获取周边主路房间(支路房间);
            foreach (var 主路房间 in 周边主路房间列表)
            {
                if (!是否已连通(支路房间, 主路房间))
                {
                    配对列表.Add(new 主路支路配对(主路房间, 支路房间));
                }
            }
        }
        return 配对列表;
    }

    private List<副本房间> 获取全部支路房间()
    {
        var 支路房间列表 = new List<副本房间>();
        for (int 行 = 0; 行 < 副本房间行数; 行++)
        {
            for (int 列 = 0; 列 < 副本房间列数; 列++)
            {
                var 房间 = 副本房间数组[行, 列];
                if (房间.路径类型 == 副本房间路径类型.分支)
                {
                    支路房间列表.Add(房间);
                }
            }
        }
        return 支路房间列表;
    }

    private List<副本房间> 获取周边主路房间(副本房间 支路房间)
    {
        var 周边主路房间 = new List<副本房间>();
        foreach (var 周边房间 in 获取周边房间(支路房间))
        {
            if (周边房间 != null && 周边房间.路径类型 == 副本房间路径类型.主路 && 周边房间 != 出口)
            {
                周边主路房间.Add(周边房间);
            }
        }
        return 周边主路房间;
    }

    private bool 是否已连通(副本房间 支路房间, 副本房间 主路房间)
    {
        if (周边房间_上(支路房间) == 主路房间) return 支路房间.上;
        if (周边房间_下(支路房间) == 主路房间) return 支路房间.下;
        if (周边房间_左(支路房间) == 主路房间) return 支路房间.左;
        if (周边房间_右(支路房间) == 主路房间) return 支路房间.右;
        return false;
    }
}
